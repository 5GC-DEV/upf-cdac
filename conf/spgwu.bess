# vim: syntax=py
# -*- mode: python -*-

# for errnos
import errno
from utils import *

# ====================================================
#       Parameters
# ====================================================


conf_file = get_env('CONF_FILE', '/conf/spgwu.json')
conf = get_json_conf(conf_file, False)
ports = {}


# ====================================================
#       Validate
# ====================================================


# CIDRs
enb_cidr = conf["enb_cidr"]
ue_cidr = conf["ue_cidr"]

cidrs = [enb_cidr, ue_cidr]
for cidr in cidrs:
    if validate_cidr(cidr) is False:
        exit(1, 'Invalid {}'.format(cidr))


# ====================================================
#       Core Setup
# ====================================================

bess.add_worker(wid=0, core=int(get_process_affinity()[0]))


# ====================================================
#       Port Setup
# ====================================================


MAX_GATES = 8192

def scan_ports():
    idx = 0
    while True:
        try:
            intf = PMDPort(name="Port {}".format(idx), port_id=idx)
            if intf:
                # Need to declare mac so that we don't lose key during destroy_port
                mac = intf.mac_addr
                ports[mac] = idx
                bess.destroy_port(intf.name)
        except bess.Error as e:
            if e.code == errno.ENODEV:
                break
            else:
                raise
        idx += 1
    return True if ports else False


def detect_mode(ifname):
    # default case
    mode = "unselected"

    try:
        peer_by_interface(ifname)
        mode = "dpdk"
    except:
        mode = "af_packet"
    return mode


def init_fastpath(ifname, tc, **kwargs):
    # Initialize PMDPort and RX/TX modules
    intf_fastp = PMDPort(name="{}_fastp".format(ifname), **kwargs)
    intf_fastp_pi = __bess_module__("{}_fastp_pi".format(ifname), 'PortInc', port=intf_fastp.name)
    intf_fastp_po = __bess_module__("{}_fastp_po".format(ifname), 'PortOut', port=intf_fastp.name)

    # Initialize BPF to classify incoming traffic to go to kernel and/or pipeline
    intf_fastp_bpf = __bess_module__("{}_fastp_bpf".format(ifname), 'BPF')
    intf_fastp_bpf.clear()

    # Default drop when no matches
    intf_fastp_pi -> intf_fastp_bpf:0 -> Sink()

    # Attach fastpath to fast TC
    intf_fastp_pi.attach_task(tc)

    return intf_fastp_pi, intf_fastp_po, intf_fastp_bpf


def setup_port(ifname, idx, fastTC, slowTC):
    print('Setting up port {}'.format(ifname))
    mode = detect_mode(ifname)

    if mode == 'af_packet':
        # Initialize kernel fastpath
        kwargs = {"vdev" : "net_af_packet{},iface={}".format(idx, ifname)}
        intf_fastp_pi, intf_fastp_po, intf_fastp_bpf = init_fastpath(ifname, fastTC, **kwargs)

    elif mode == 'dpdk':
        # if port list is empty, scan for ports first
        if not ports and scan_ports() == False:
            print('Registered ports do not exist.')
            sys.exit()
        # Initialize DPDK fastpath
        intf_fastp_idx = ports.get(mac_by_interface(ifname))
        if intf_fastp_idx is None:
            raise Exception('Registered port for {} not detected!'.format(ifname))
        kwargs = {"port_id" : intf_fastp_idx}
        intf_fastp_pi, intf_fastp_po, intf_fastp_bpf = init_fastpath(ifname, fastTC, **kwargs)

        # Initialize kernel slowpath port and RX/TX modules
        try:
            peer = peer_by_interface(ifname)
            vdev = "net_af_packet{},iface={}".format(idx, peer)
            intf_slowp = PMDPort(name="{}_slowp".format(ifname), vdev=vdev)
            intf_slowp_pi = __bess_module__("{}_slowp_pi".format(ifname), 'PortInc', port=intf_slowp.name)
            intf_slowp_po = __bess_module__("{}_slowp_po".format(ifname), 'PortOut', port=intf_slowp.name)
            q_slowp_po = __bess_module__("{}_q_slowp_po".format(ifname), 'Queue')

            # host_ip_filter: tcpdump -i foo 'dst host 198.19.0.1 or 198.18.0.1' -d
            HostGate = MAX_GATES - 1
            ips = ips_by_interface(ifname)
            host_ip_filter = {"priority": -HostGate, "filter": "dst host "
                              + " or ".join(str(x) for x in ips), "gate": HostGate}

            intf_fastp_bpf.add(filters=[host_ip_filter])

            # Direct control traffic from DPDK to kernel
            intf_fastp_bpf:HostGate -> q_slowp_po -> intf_slowp_po

            # Direct control traffic from kernel to DPDK
            intf_slowp_pi -> intf_fastp_po

            # Limit scheduling slow path RX/TX to 1000 times/second each
            for mod in intf_slowp_pi, q_slowp_po:
                bess.add_tc(mod.name,
                        parent=slowTC,
                        policy='rate_limit',
                        resource='count',
                        limit={'count': 1000})
                mod.attach_task(mod.name)
        except Exception as e:
            print('Mirror veth interface: {} misconfigured: {}'.format(ifname, e))
    else:
        raise Exception('Invalid mode selected.')


interfaces = ["s1u", "sgi"]
done = []
bess.add_tc('fast', policy='round_robin', wid=0)
bess.add_tc('slow', policy='round_robin', wid=0)
for idx, interface in enumerate(interfaces):
    ifname = conf[interface]["ifname"]
    if ifname in done:
        continue
    setup_port(ifname, idx, 'fast', 'slow')
    done.append(ifname)

# ====================================================
#       Uplink Pipeline
# ====================================================


s1u_ifname = conf["s1u"]["ifname"]
sgi_ifname = conf["sgi"]["ifname"]

# TODO: Handle routes for directly connected vs. via next hop differently
sgi_routes::IPLookup()
# Adding default route
sgi_routes.add(prefix='0.0.0.0', prefix_len=0, gate=MAX_GATES-1)

# Setting filter to detect gtpu traffic
# src net 11.1.1.0 mask 255.255.255.0           # check eNB subnet
# and dst host 11.1.1.1                         # check S/PGWU IP
# and udp dst port 2152                         # check GTPU port
# and (udp[28:4] & 0xffffff00) = 0x10000000     # check UE subnet
GTPUGate = 1
check_enb_subnet = "src net {} ".format(enb_cidr)
check_spgwu_ip = " and dst host " + \
    " or ".join(str(x) for x in ips_by_interface(s1u_ifname))
check_gtpu_port = " and udp dst port 2152"
check_ue_subnet = " and (udp[28:4] & 0x{}) = 0x{}".format(
    cidr2mask(ue_cidr), ip2hex(cidr2block(ue_cidr)[0]))

uplink_filter = {"priority": -GTPUGate, "filter": check_enb_subnet +
               check_spgwu_ip + check_gtpu_port + check_ue_subnet, "gate": GTPUGate}
s1u_fastp_bpf.add(filters=[uplink_filter])

s1u_fastp_bpf:GTPUGate -> GetPDU_sgi::GenericDecap(bytes=50) \
    -> sgi_ether_encap::GenericEncap(fields=[
        {'size': 6, 'value': {'value_int': 0x0}},
        {'size': 6, 'value': {'value_int': mac2hex(mac_by_interface(sgi_ifname))}},
        {'size': 2, 'value': {'value_int': 0x0800}}]) \
    -> sgi_routes:(MAX_GATES-1) -> Sink()


# ====================================================
#       Downlink Pipeline
# ====================================================


# Maximum number of sessions to manage
max_sessions = conf["max_sessions"]

# TODO: Handle routes for directly connected vs. via next hop differently
s1u_routes::IPLookup()
# Adding default route
s1u_routes.add(prefix='0.0.0.0', prefix_len=0, gate=MAX_GATES-1)

# Setting filter to detect UE subnet
UEGate = 1
ue_filter = {"priority": -UEGate,
             "filter": "ip dst net {}".format(ue_cidr), "gate": UEGate}
sgi_fastp_bpf.add(filters=[ue_filter])

sgi_fastp_bpf:UEGate \
    -> GenericDecap(bytes=14) \
    -> gtpu_encap::GtpuEncap(s1u_sgw_ip=ip2long(ips_by_interface(s1u_ifname)[0]), num_subscribers=max_sessions):1 \
    -> s1u_ether_encap::GenericEncap(fields=[
        {'size': 6, 'value': {'value_int': 0x0}},
        {'size': 6, 'value': {'value_int': mac2hex(mac_by_interface(s1u_ifname))}},
        {'size': 2, 'value': {'value_int': 0x0800}}]) \
    -> L4Checksum() \
    -> IPChecksum() \
    -> s1u_routes:(MAX_GATES-1) -> Sink()

# Drop unknown packets
gtpu_encap:0 -> Sink()

# ====================================================
#       SIM_TEST
# ====================================================

import time

def sim_start_test():
    start_teid = 0xf0000000
    start_ue_ip = 0x10000001
    start_enb_ip = 0x0b010181
    NG4T_MAX_UE_RAN = 500000
    NG4T_MAX_ENB_RAN = 80

    for i in range(max_sessions):

        # NG4T-based formula to calculate enodeB IP address against a given UE IP address
        # il_trafficgen also uses the same scheme
        # See SimuCPEnbv4Teid(...) in ngic code for more details
        ue_of_ran = i % NG4T_MAX_UE_RAN
        ran = i / NG4T_MAX_UE_RAN
        enb_of_ran = ue_of_ran % NG4T_MAX_ENB_RAN
        enb_idx = ran * NG4T_MAX_ENB_RAN + enb_of_ran

        gtpu_encap.add(teid=start_teid+i, ueaddr=start_ue_ip+i, enodeb_ip=start_enb_ip+enb_idx)

def sim_end_test():
    start_ue_ip = 0x10000001

    for i in range(max_sessions):
        gtpu_encap.remove(ueaddr=start_ue_ip+i)

    gtpu_encap.show_records()

### Uncomment the following lines to test with il_trafficgen ###
# Start the test
#sim_start_test()
# Wait for 30 seconds before deleting the session info entries (optional)
#time.sleep(30)
#sim_end_test()

# Finally send SIGHUP to route_control daemon on reload
# TODO: behavior is unspecified if route_control.py pid is not found
route_control_pid = getpythonpid('route_control.py')
if route_control_pid:
    os.kill(route_control_pid, signal.SIGHUP)

#vim: syntax=py

import socket

def aton(ip):
    return socket.inet_aton(ip)

#====================================================
#       Port Setup
#====================================================

s1u_ip = "1.1.1.10"
sgi_ip = "2.2.2.10"

s1u = PMDPort(name="s1u", vdev="net_af_packet0,iface=s1u")
sgi = PMDPort(name="sgi", vdev="net_af_packet1,iface=sgi")

s1u_dpdk = PMDPort(name="s1u_dpdk", port_id=0)
sgi_dpdk = PMDPort(name="sgi_dpdk", port_id=1)

#====================================================
#       Misc Setup
#====================================================

merge_s1u::Merge() -> PortOut(port=s1u_dpdk.name)
merge_sgi::Merge() -> PortOut(port=sgi_dpdk.name)

# PortInc(port=s1u) -> merge_s1u
# PortInc(port=sgi) -> merge_sgi

PortInc(port=s1u_dpdk.name) -> s1u_bpf::BPF()
PortInc(port=sgi_dpdk.name) -> sgi_bpf::BPF()

#====================================================
#       Uplink Pipeline
#====================================================

s1u_bpf:0 -> Sink()
s1u_bpf:1 -> PortOut(port=s1u.name)
# TODO - add a TEID and UE IP check
s1u_bpf:2 -> GenericDecap(bytes=50) -> EtherEncap() -> s1u_ipfwd::IPLookup()

# Separate out traffic
#   1: ARP for me
#   2: Any traffic destined to me
filter1 = {"priority": -1, "filter": "arp host {}".format(s1u_ip), "gate": 1}
filter2 = {"priority": -2, "filter": "udp dst port 2152 and dst host {}".format(s1u_ip), "gate": 2}
s1u_bpf.clear()
s1u_bpf.add(filters=[filter1, filter2])

# Add routes and update src/dst MAC accordingly
# TODO - make this dynamic using pyroute2
s1u_ipfwd.add(prefix='0.0.0.0', prefix_len=0, gate=0)
s1u_ipfwd:0 \
    -> Update(fields=[{'offset': 0, 'size': 6, 'value': 0x1234567890ab},
                      {'offset': 6, 'size': 6, 'value': 0x1234567890ab}]) \
    -> merge_sgi

#====================================================
#       Downlink Pipeline
#====================================================

sgi_bpf:0 -> Sink()
sgi_bpf:1 -> PortOut(port=sgi.name)
sgi_bpf:2 -> GenericDecap(bytes=14) -> ue_dstip::ExactMatch(fields=[{'offset':16, 'num_bytes':4}])

# Separate out traffic
#   1: ARP for me
#   2: Any traffic NOT destined to me
filter1 = {"priority": -1, "filter": "arp host {}".format(sgi_ip), "gate": 1}
filter2 = {"priority": -2, "filter": "ip and not dst host {}".format(sgi_ip), "gate": 2}
sgi_bpf.clear()
sgi_bpf.add(filters=[filter1, filter2])

ue_dstip:0 -> Sink()
ue_dstip.set_default_gate(gate=0)

# Match dst IP UE and encap it with specific TIED and Outer IP src s1u and dst enb
# GTPencap -> UDPencap -> IPencap -> EtherEncap -> L4checksum -> ipchecksum
# TODO - make this dynamic using PFCP or CPDP messages
ue_dstip:1 \
    -> SetMetadata(attrs=[
        {'name': 'ip_src', 'size': 4, 'value_bin': aton(s1u_ip)},
        {'name': 'ip_dst', 'size': 4, 'value_bin': '\x02\x0a\x0b\x0c'},
        {'name': 'ip_proto', 'size': 1, 'value_bin': '\x11'}]) \
    -> SetMetadata(attrs=[
        {'name': 'ether_src', 'size': 6, 'value_bin': '\x02\x01\x02\x03\x04\x05'},
        {'name': 'ether_dst', 'size': 6, 'value_bin': '\x02\x0a\x0b\x0c\x0d\x0e'}]) \
    -> GTPencap::GenericEncap(fields=[
        {'size': 6, 'value': {'value_int': 0x020000000001}},
        {'size': 6, 'value': {'value_int': 0x0619deadbeef}},
        {'size': 2, 'attribute': 'ether_type'}]) \
    -> UDPencap::GenericEncap(fields=[
        {'size': 6, 'value': {'value_int': 0x020000000001}},
        {'size': 6, 'value': {'value_int': 0x0619deadbeef}},
        {'size': 2, 'attribute': 'ether_type'}]) \
    -> IPEncap() -> EtherEncap() -> L4Checksum() -> IPChecksum() -> merge_s1u
ue_dstip.add(fields=[{'value_bin': aton('12.34.56.78')}], gate=1)

#====================================================
#       Test Setup
#====================================================

PortInc(port=s1u) -> Sink()
PortInc(port=sgi) -> Sink()

import scapy.all as scapy

eth_header = scapy.Ether(src='02:00:00:00:00:01', dst='ff:ff:ff:ff:ff:ff')
arp_header = scapy.ARP(op=1, pdst=s1u_ip, psrc='1.1.1.11')
pkt = eth_header/arp_header
packets = [str(pkt)]
s1u_arpsrc::Source() -> Rewrite(templates=packets) -> s1u_bpf
bess.add_tc('s1u_arp_pps',
            policy='rate_limit',
            resource='packet',
            limit={'packet': 1})
s1u_arpsrc.attach_task(parent='s1u_arp_pps')


eth_header = scapy.Ether(src='02:00:00:00:00:02', dst='ff:ff:ff:ff:ff:ff')
arp_header = scapy.ARP(op=1, pdst=sgi_ip, psrc='2.2.2.11')
pkt = eth_header/arp_header
packets = [str(pkt)]
sgi_arpsrc::Source() -> Rewrite(templates=packets) -> sgi_bpf
bess.add_tc('sgi_arp_pps',
            policy='rate_limit',
            resource='packet',
            limit={'packet': 1})
sgi_arpsrc.attach_task(parent='sgi_arp_pps')
